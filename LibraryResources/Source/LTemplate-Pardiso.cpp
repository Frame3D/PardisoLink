/*  This file was automatically generated by LTemplate. DO NOT EDIT.  */
/*  https://github.com/szhorvat/LTemplate  */

#define LTEMPLATE_MMA_VERSION  1200

#include "LTemplate.h"
#include "LTemplateHelpers.h"
#include "Pardiso.h"


#define LTEMPLATE_MESSAGE_SYMBOL  "PardisoLink`PardisoLink"

#include "LTemplate.inc"


std::map<mint, Pardiso *> Pardiso_collection;

namespace mma
{
	template<> const std::map<mint, Pardiso *> & getCollection<Pardiso>()
	{
		return Pardiso_collection;
	}
}

DLLEXPORT void Pardiso_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
	if (mode == 0) { // create
	  Pardiso_collection[id] = new Pardiso();
	} else {  // destroy
	  if (Pardiso_collection.find(id) == Pardiso_collection.end()) {
	    libData->Message("noinst");
	    return;
	  }
	  delete Pardiso_collection[id];
	  Pardiso_collection.erase(id);
	}
}

extern "C" DLLEXPORT int Pardiso_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::TensorRef<mint> res = mma::detail::get_collection(Pardiso_collection);
	mma::detail::setTensor<mint>(Res, res);
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT mint WolframLibrary_getVersion()
{
	return WolframLibraryVersion;
}

extern "C" DLLEXPORT int WolframLibrary_initialize(WolframLibraryData libData)
{
	mma::libData = libData;
	{
		int err;
		err = (*libData->registerLibraryExpressionManager)("Pardiso", Pardiso_manager_fun);
		if (err != LIBRARY_NO_ERROR) return err;
	}
	return LIBRARY_NO_ERROR;
}

extern "C" DLLEXPORT void WolframLibrary_uninitialize(WolframLibraryData libData)
{
	(*libData->unregisterLibraryExpressionManager)("Pardiso");
	return;
}


extern "C" DLLEXPORT int Pardiso_RowPointers(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> res = (Pardiso_collection[id])->RowPointers();
		mma::detail::setTensor<mint>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::RowPointers()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::RowPointers()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_ColumnIndices(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> res = (Pardiso_collection[id])->ColumnIndices();
		mma::detail::setTensor<mint>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::ColumnIndices()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::ColumnIndices()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_NonzeroValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<double> res = (Pardiso_collection[id])->NonzeroValues();
		mma::detail::setTensor<double>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::NonzeroValues()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::NonzeroValues()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_TimeStamp(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		double res = (Pardiso_collection[id])->TimeStamp();
		MArgument_setReal(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::TimeStamp()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::TimeStamp()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_IntegerParameters(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> res = (Pardiso_collection[id])->IntegerParameters();
		mma::detail::setTensor<mint>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::IntegerParameters()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::IntegerParameters()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_NumberOfNonzeros(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->NumberOfNonzeros();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::NumberOfNonzeros()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::NumberOfNonzeros()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_Length(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->Length();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::Length()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::Length()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_Error(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->Error();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::Error()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::Error()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_MatrixType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->MatrixType();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::MatrixType()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::MatrixType()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_CheckMatrixQ(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->CheckMatrixQ();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::CheckMatrixQ()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::CheckMatrixQ()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_Permutation(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> res = (Pardiso_collection[id])->Permutation();
		mma::detail::setTensor<mint>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::Permutation()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::Permutation()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_Init(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
		mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
		mma::TensorRef<double> var3 = mma::detail::getTensor<double>(Args[3]);
		mint var4 = MArgument_getInteger(Args[4]);
		
		(Pardiso_collection[id])->Init(var1, var2, var3, var4);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::Init()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::Init()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_SetNonzeroValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
		
		mint res = (Pardiso_collection[id])->SetNonzeroValues(var1);
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::SetNonzeroValues()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::SetNonzeroValues()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_SetIntegerParameters(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
		
		mint res = (Pardiso_collection[id])->SetIntegerParameters(var1);
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::SetIntegerParameters()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::SetIntegerParameters()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_SetTimeStamp(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		double var1 = MArgument_getReal(Args[1]);
		
		mint res = (Pardiso_collection[id])->SetTimeStamp(var1);
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::SetTimeStamp()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::SetTimeStamp()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_SetCheckMatrixQ(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint var1 = MArgument_getInteger(Args[1]);
		
		mint res = (Pardiso_collection[id])->SetCheckMatrixQ(var1);
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::SetCheckMatrixQ()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::SetCheckMatrixQ()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_SetPermutations(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
		
		mint res = (Pardiso_collection[id])->SetPermutations(var1);
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::SetPermutations()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::SetPermutations()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_FactorizeSymbolically(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->FactorizeSymbolically();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::FactorizeSymbolically()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::FactorizeSymbolically()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_FactorizeNumerically(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mint res = (Pardiso_collection[id])->FactorizeNumerically();
		MArgument_setInteger(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::FactorizeNumerically()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::FactorizeNumerically()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int Pardiso_LinearSolve(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
	mma::detail::MOutFlushGuard flushguard;
	const mint id = MArgument_getInteger(Args[0]);
	if (Pardiso_collection.find(id) == Pardiso_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }
	
	try
	{
		mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
		mint var2 = MArgument_getInteger(Args[2]);
		mint var3 = MArgument_getInteger(Args[3]);
		
		mma::TensorRef<double> res = (Pardiso_collection[id])->LinearSolve(var1, var2, var3);
		mma::detail::setTensor<double>(Res, res);
	}
	catch (const mma::LibraryError & libErr)
	{
		libErr.report();
		return libErr.error_code();
	}
	catch (const std::exception & exc)
	{
		mma::detail::handleUnknownException(exc.what(), "Pardiso::LinearSolve()");
		return LIBRARY_FUNCTION_ERROR;
	}
	catch (...)
	{
		mma::detail::handleUnknownException(NULL, "Pardiso::LinearSolve()");
		return LIBRARY_FUNCTION_ERROR;
	}
	
	return LIBRARY_NO_ERROR;
}


